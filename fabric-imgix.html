<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-image/iron-image.html">

<dom-module id="fabric-imgix">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <iron-image
      src$="[[path]]"
      preload
      fade
    ></iron-image>
  </template>

  <script>
    /* eslint-disable max-len */

    /**
     * imgIX properties array
     * https://docs.imgix.com/apis/url
     * Keep them sync with all the properties at the top
     */
    const imgIXProperties = [
      '~text',
      'auto',
      'ba',
      'balph',
      'bc',
      'bf',
      'bg',
      'bh',
      'blend',
      'blur',
      'bm',
      'border-radius-inner',
      'border-radius',
      'border',
      'bp',
      'bri',
      'bs',
      'bw',
      'bx',
      'by',
      'ch',
      'chromasub',
      'colorquant',
      'colors',
      'con',
      'corner-radius',
      'crop',
      'cs',
      'dl',
      'dpi',
      'dpr',
      'exp',
      'faceindex',
      'facepad',
      'faces',
      'fit',
      'flip',
      'fm',
      'fp-debug',
      'fp-x',
      'fp-y',
      'fp-z',
      'gam',
      'h',
      'high',
      'htn',
      'hue',
      'invert',
      'lossless',
      'mark',
      'markalign',
      'markalpha',
      'markbase',
      'markfit',
      'markh',
      'markpad',
      'markscale',
      'markw',
      'markx',
      'marky',
      'mask',
      'maskbg',
      'max-h',
      'max-w',
      'min-h',
      'min-w',
      'mono',
      'nr',
      'nrs',
      'or',
      'pad',
      'page',
      'palette',
      'px',
      'q',
      'rect',
      'rot',
      'sat',
      'sepia',
      'shad',
      'sharp',
      'trim',
      'trimcolor',
      'trimmd',
      'trimsd',
      'trimtol',
      'txt',
      'txtalign',
      'txtclip',
      'txtclr',
      'txtfit',
      'txtfont',
      'txtlead',
      'txtlig',
      'txtline',
      'txtlineclr',
      'txtpad',
      'txtshad',
      'txtsize',
      'txttrack',
      'txtwidth',
      'usm',
      'usmrad',
      'vib',
      'w',
    ];

    /**
     * iron-image properties object
     * Keep them sync with all the properties on iron-image
     */
    const ironImageProperties = {
      /**
       * The URL of an image.
       */
      src: {
        type: String,
        value: '',
      },

      /**
       * A short text alternative for the image.
       */
      alt: {
        type: String,
        value: null,
      },

      /**
       * CORS enabled images support: https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
       */
      crossorigin: {
        type: String,
        value: null,
      },

      /**
       * When true, the image is prevented from loading and any placeholder is
       * shown.  This may be useful when a binding to the src property is known to
       * be invalid, to prevent 404 requests.
       */
      preventLoad: {
        type: Boolean,
        value: false,
      },

      /**
       * Sets a sizing option for the image.  Valid values are `contain` (full
       * aspect ratio of the image is contained within the element and
       * letterboxed) or `cover` (image is cropped in order to fully cover the
       * bounds of the element), or `null` (default: image takes natural size).
       */
      sizing: {
        type: String,
        value: null,
        reflectToAttribute: true,
      },

      /**
       * When a sizing option is used (`cover` or `contain`), this determines
       * how the image is aligned within the element bounds.
       */
      position: {
        type: String,
        value: 'center',
      },

      /**
       * When `true`, any change to the `src` property will cause the `placeholder`
       * image to be shown until the new image has loaded.
       */
      preload: {
        type: Boolean,
        value: false,
      },

      /**
       * This image will be used as a background/placeholder until the src image has
       * loaded.  Use of a data-URI for placeholder is encouraged for instant rendering.
       */
      placeholder: {
        type: String,
        value: null,
        // observer: '_placeholderChanged'
      },

      /**
       * When `preload` is true, setting `fade` to true will cause the image to
       * fade into place.
       */
      fade: {
        type: Boolean,
        value: false,
      },

      /**
       * Read-only value that is true when the image is loaded.
       */
      loaded: {
        notify: true,
        readOnly: true,
        type: Boolean,
        value: false,
      },

      /**
       * Read-only value that tracks the loading state of the image when the `preload`
       * option is used.
       */
      loading: {
        notify: true,
        readOnly: true,
        type: Boolean,
        value: false,
      },

      /**
       * Read-only value that indicates that the last set `src` failed to load.
       */
      error: {
        notify: true,
        readOnly: true,
        type: Boolean,
        value: false,
      },

      /**
       * Can be used to set the width of image (e.g. via binding); size may also be
       * set via CSS.
       */
      width: {
        type: Number,
        value: null,
      },

      /**
       * Can be used to set the height of image (e.g. via binding); size may also be
       * set via CSS.
       *
       * @attribute height
       * @type number
       * @default null
       */
      height: {
        type: Number,
        value: null,
      },
    };

    /**
     * `fabric-imgix`
     *
     *
     * @customElement
     * @polymer
     * @extends Polymer.Element
     * @demo demo/index.html
     */
    class FabricImgix extends Polymer.Element {
      /**
       * @return {string}
       */
      static get is() {
        return 'fabric-imgix';
      }

      /**
       * @return {Array}
       */
      static get imgIXProperties() {
        return imgIXProperties;
      }

      /**
       * @return {Object}
       */
      static get ironImageProperties() {
        return ironImageProperties;
      }

      /**
       * @return {Object}
       */
      static get imgIXPropertiesObject() {
        let properties = {};
        for (let i = 0; i < imgIXProperties.length; i++) {
          /*
          const propertyName = imgIXProperties[i].replace(/-([a-z])/g, (g) => {
            return g[1].toUpperCase();
          });
          properties[propertyName] = String;*/
          properties[imgIXProperties[i]] = String;
        }
        return properties;
      }

      /**
       * @return {object}
       */
      static get properties() {
        // Iron image properties
        const ironImage = FabricImgix.ironImageProperties;
        // imgIX base properties
        const imgIX = FabricImgix.imgIXPropertiesObject;
        // Component base properties
        const componentProperties = {
          /**
           * Detects the available size of the component
           * and apply it to the size of the component
           */
          smart: {
            type: Boolean,
            value: false,
            observer: '_getBounding',
          },
          path: {
            type: String,
            value: null,
          },
        };

        /**
         * Merge all property objects
         */
        return Object.assign(ironImage, imgIX, componentProperties);
      }

      /**
       * Connected callback
       */
      connectedCallback() {
        super.connectedCallback();
        this._getBounding();
        window.addEventListener('resize', () => this._getBounding());
      }

      /**
       * @return {array}
       */
      static get observers() {
        return [
          `_globalObserver(sizing, ${FabricImgix.imgIXProperties})`,
        ];
      }

      /**
       * Assemble Url
       *
       * @return {Object}
       * @private
       */
      _getBounding() {
        const clientRect = this.getBoundingClientRect();
        if (this.smart) {
          this.fit = 'crop';
          this.h = clientRect.height;
          this.w = clientRect.width;
          this['max-h'] = clientRect.height;
          this['max-w'] = clientRect.width;
        }
        return clientRect;
      }

      /**
       * imgIX changed
       *
       * @return {any}
       * @private
       */
      _globalObserver() {
        if (!this.src) return this.path = null;
        let path = `${this.src}?`;
        const properties = FabricImgix.imgIXProperties;
        let imgIXObject = {};
        if (this.sizing === 'cover') {
          this.smart = true;
        }
        if (this.sizing === 'contain') {
          const size = this._getBounding();
          this['max-h'] = size.height;
          this['max-w'] = size.width;
        }
        for (let i = 0; i < properties.length; i++) {
          const name = properties[i];
          if (this[name]) {
            imgIXObject[name] = this[name];
            path += `${name}=${this[name]}&`;
          }
        }
        this.path = path;
      }
    }

    window.customElements.define(FabricImgix.is, FabricImgix);
  </script>
</dom-module>
